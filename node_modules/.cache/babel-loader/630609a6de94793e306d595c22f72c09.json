{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.getMaxValue = getMaxValue;\nexports.createTree = createTree;\nexports.getNodeBranchHeight = getNodeBranchHeight;\nexports.getTreeNodes = getTreeNodes;\nexports.getTreePaths = getTreePaths;\n\nvar _orderBy = require('lodash/orderBy');\n\nvar _orderBy2 = _interopRequireDefault(_orderBy);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // It is supposed that root node has id=ROOT_ID and the largest value\n\n\nfunction getMaxValue(rootID, nodes) {\n  return nodes[rootID].value;\n}\n\nfunction reconcileNodeX(node, chartConfig, level) {\n  return _extends({}, node, {\n    x: (chartConfig.node.width + chartConfig.link.width) * level\n  });\n}\n\nfunction reconcileNodeHeight(node, chartConfig, maxValue) {\n  return _extends({}, node, {\n    height: Math.max(parseInt(node.value / maxValue * chartConfig.node.maxHeight, 10), chartConfig.node.rectMinHeight)\n  });\n}\n\nfunction reconcileNodeChildren(node, chartConfig, rootID, links, nodes, sourceId, level) {\n  var children = links.filter(function (link) {\n    return link.sourceId == sourceId;\n  }).map(function (link) {\n    return _extends({}, createTree(chartConfig, rootID, links, nodes, link.targetId, level + 1), {\n      parent: node\n    });\n  }); // eslint-disable-line no-use-before-define\n\n  return _extends({}, node, {\n    children: (0, _orderBy2.default)(children, ['value'], ['desc'])\n  });\n}\n/**\n * Creates tree structure and prepares some data that will be used to calculate position of each node\n */\n\n\nfunction createTree(chartConfig, rootID, links, nodes, sourceId) {\n  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  var node = _extends({}, nodes[sourceId], {\n    level: level,\n    y: 0,\n    x: 0,\n    height: 0,\n    children: [],\n    isFirstChild: false,\n    isLastChild: false,\n    parent: null\n  });\n\n  node = reconcileNodeX(node, chartConfig, level);\n  node = reconcileNodeHeight(node, chartConfig, getMaxValue(rootID, nodes));\n  node = reconcileNodeChildren(node, chartConfig, rootID, links, nodes, sourceId, level);\n  return node;\n}\n\nfunction getChildrenHeight(chartConfig, children, initialValue) {\n  return children.reduce(function (height, child) {\n    return height + getNodeBranchHeight(chartConfig, child) + chartConfig.node.paddingBottom;\n  }, initialValue); // eslint-disable-line no-use-before-define\n} // Returns max height of branch for given node (node is assumed as root for this branch)\n\n\nfunction branchMaxHeight(chartConfig, node) {\n  var childrenHeight = getChildrenHeight(chartConfig, node.children, 0);\n  return childrenHeight - chartConfig.node.paddingBottom;\n} // Return height of branch for given node\n\n\nfunction getNodeBranchHeight(chartConfig, node) {\n  return Math.max(branchMaxHeight(chartConfig, node), node.height, chartConfig.node.minHeight);\n} // find y position of child according to y position of parent and children before this child\n\n\nfunction getYChild(chartConfig, parent, currentChildIndex) {\n  return getChildrenHeight(chartConfig, parent.children.slice(0, currentChildIndex), parent.y);\n}\n/**\n * Return tree nodes as flat array and calculate y position of each node.\n */\n\n\nfunction getTreeNodes(chartConfig, tree) {\n  var result = [tree];\n\n  var getChildren = function getChildren(node) {\n    // get children with proper y position\n    var children = node.children.map(function (child, i) {\n      return _extends({}, child, {\n        y: getYChild(chartConfig, node, i),\n        isFirstChild: i === 0,\n        isLastChild: i === node.children.length - 1\n      });\n    });\n    result = result.concat(children);\n    children.forEach(function (child) {\n      return getChildren(child);\n    });\n  };\n\n  getChildren(tree);\n  return result;\n} // Returns d attribute to build proper path between nodes\n\n\nfunction getTreePaths(chartConfig, links, nodes) {\n  return links.map(function (link) {\n    var sourceNode = nodes.find(function (node) {\n      return node.id == link.sourceId;\n    });\n    var targetNode = nodes.find(function (node) {\n      return node.id == link.targetId;\n    });\n\n    if (!sourceNode || !targetNode) {\n      throw new Error('should never happen');\n    }\n\n    var x1 = sourceNode.x,\n        y1 = sourceNode.y;\n    var x2 = targetNode.x,\n        y2 = targetNode.y;\n    var targetsHeight = sourceNode.children.reduce(function (height, child) {\n      return height + child.height;\n    }, 0);\n    var targetIndex = sourceNode.children.findIndex(function (child) {\n      return child.id == targetNode.id;\n    });\n    var curvesStartPositionsPercents = sourceNode.children.map(function (child) {\n      return child.height * 100 / targetsHeight;\n    }); // Get y of first point of path\n\n    var cy1 = y1;\n\n    for (var k = 0; k < targetIndex; k += 1) {\n      cy1 += curvesStartPositionsPercents[k] * sourceNode.height / 100;\n    } // Get y of last point of path\n\n\n    var cy2 = y1;\n\n    for (var _k = 0; _k <= targetIndex; _k += 1) {\n      cy2 += curvesStartPositionsPercents[_k] * sourceNode.height / 100;\n    }\n\n    var d = '\\n      M' + (x1 + chartConfig.node.width) + ' ' + cy1 + '\\n      C' + (x2 - chartConfig.link.width / 2) + ' ' + cy1 + ' ' + (x2 - chartConfig.link.width / 2) + ' ' + y2 + ' ' + x2 + ' ' + y2 + ' \\n      V' + (y2 + targetNode.height) + '\\n      C' + (x2 - chartConfig.link.width / 2) + ' ' + (y2 + targetNode.height) + ' ' + (x2 - chartConfig.link.width / 2) + ' ' + cy2 + ' ' + (x1 + chartConfig.node.width) + ' ' + cy2 + '\\n    ';\n    return {\n      id: sourceNode.id + '_' + targetNode.id,\n      d: d\n    };\n  });\n}","map":null,"metadata":{},"sourceType":"script"}